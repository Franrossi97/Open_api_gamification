/**
 * Gamification_platform
 * The API will be use for the final assesment
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { Achievement } from '../model/achievement';
import { AchievementArray } from '../model/achievementArray';
import { BadgeArray } from '../model/badgeArray';
import { BasicUserInformationArray } from '../model/basicUserInformationArray';
import { CompleteAttemptInfo } from '../model/completeAttemptInfo';
import { FinalUserInformation } from '../model/finalUserInformation';
import { Flashcard } from '../model/flashcard';
import { FlashcardArray } from '../model/flashcardArray';
import { FlashcardItemArray } from '../model/flashcardItemArray';
import { FlashcardResultArray } from '../model/flashcardResultArray';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse2001 } from '../model/inlineResponse2001';
import { InlineResponse20010 } from '../model/inlineResponse20010';
import { InlineResponse20011 } from '../model/inlineResponse20011';
import { InlineResponse20012 } from '../model/inlineResponse20012';
import { InlineResponse20013 } from '../model/inlineResponse20013';
import { InlineResponse20014 } from '../model/inlineResponse20014';
import { InlineResponse20015 } from '../model/inlineResponse20015';
import { InlineResponse20016 } from '../model/inlineResponse20016';
import { InlineResponse20017 } from '../model/inlineResponse20017';
import { InlineResponse20018 } from '../model/inlineResponse20018';
import { InlineResponse20019 } from '../model/inlineResponse20019';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InlineResponse20020 } from '../model/inlineResponse20020';
import { InlineResponse20021 } from '../model/inlineResponse20021';
import { InlineResponse20022 } from '../model/inlineResponse20022';
import { InlineResponse20023 } from '../model/inlineResponse20023';
import { InlineResponse20024 } from '../model/inlineResponse20024';
import { InlineResponse20025 } from '../model/inlineResponse20025';
import { InlineResponse20026 } from '../model/inlineResponse20026';
import { InlineResponse20027 } from '../model/inlineResponse20027';
import { InlineResponse20028 } from '../model/inlineResponse20028';
import { InlineResponse20029 } from '../model/inlineResponse20029';
import { InlineResponse2003 } from '../model/inlineResponse2003';
import { InlineResponse20030 } from '../model/inlineResponse20030';
import { InlineResponse20031 } from '../model/inlineResponse20031';
import { InlineResponse20032 } from '../model/inlineResponse20032';
import { InlineResponse20033 } from '../model/inlineResponse20033';
import { InlineResponse20034 } from '../model/inlineResponse20034';
import { InlineResponse20035 } from '../model/inlineResponse20035';
import { InlineResponse20036 } from '../model/inlineResponse20036';
import { InlineResponse20037 } from '../model/inlineResponse20037';
import { InlineResponse20038 } from '../model/inlineResponse20038';
import { InlineResponse20039 } from '../model/inlineResponse20039';
import { InlineResponse2004 } from '../model/inlineResponse2004';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { InlineResponse2007 } from '../model/inlineResponse2007';
import { InlineResponse2008 } from '../model/inlineResponse2008';
import { InlineResponse2009 } from '../model/inlineResponse2009';
import { InlineResponse400 } from '../model/inlineResponse400';
import { InlineResponse4001 } from '../model/inlineResponse4001';
import { InlineResponse40010 } from '../model/inlineResponse40010';
import { InlineResponse40011 } from '../model/inlineResponse40011';
import { InlineResponse40012 } from '../model/inlineResponse40012';
import { InlineResponse40013 } from '../model/inlineResponse40013';
import { InlineResponse40014 } from '../model/inlineResponse40014';
import { InlineResponse40015 } from '../model/inlineResponse40015';
import { InlineResponse40016 } from '../model/inlineResponse40016';
import { InlineResponse40017 } from '../model/inlineResponse40017';
import { InlineResponse40018 } from '../model/inlineResponse40018';
import { InlineResponse40019 } from '../model/inlineResponse40019';
import { InlineResponse4002 } from '../model/inlineResponse4002';
import { InlineResponse40020 } from '../model/inlineResponse40020';
import { InlineResponse40021 } from '../model/inlineResponse40021';
import { InlineResponse40022 } from '../model/inlineResponse40022';
import { InlineResponse40023 } from '../model/inlineResponse40023';
import { InlineResponse40024 } from '../model/inlineResponse40024';
import { InlineResponse40025 } from '../model/inlineResponse40025';
import { InlineResponse40026 } from '../model/inlineResponse40026';
import { InlineResponse40027 } from '../model/inlineResponse40027';
import { InlineResponse40028 } from '../model/inlineResponse40028';
import { InlineResponse40029 } from '../model/inlineResponse40029';
import { InlineResponse4003 } from '../model/inlineResponse4003';
import { InlineResponse40030 } from '../model/inlineResponse40030';
import { InlineResponse40031 } from '../model/inlineResponse40031';
import { InlineResponse40032 } from '../model/inlineResponse40032';
import { InlineResponse40033 } from '../model/inlineResponse40033';
import { InlineResponse40034 } from '../model/inlineResponse40034';
import { InlineResponse40035 } from '../model/inlineResponse40035';
import { InlineResponse40036 } from '../model/inlineResponse40036';
import { InlineResponse40037 } from '../model/inlineResponse40037';
import { InlineResponse40038 } from '../model/inlineResponse40038';
import { InlineResponse40039 } from '../model/inlineResponse40039';
import { InlineResponse4004 } from '../model/inlineResponse4004';
import { InlineResponse40040 } from '../model/inlineResponse40040';
import { InlineResponse40041 } from '../model/inlineResponse40041';
import { InlineResponse40042 } from '../model/inlineResponse40042';
import { InlineResponse40043 } from '../model/inlineResponse40043';
import { InlineResponse40044 } from '../model/inlineResponse40044';
import { InlineResponse40045 } from '../model/inlineResponse40045';
import { InlineResponse40046 } from '../model/inlineResponse40046';
import { InlineResponse40047 } from '../model/inlineResponse40047';
import { InlineResponse40048 } from '../model/inlineResponse40048';
import { InlineResponse40049 } from '../model/inlineResponse40049';
import { InlineResponse4005 } from '../model/inlineResponse4005';
import { InlineResponse40050 } from '../model/inlineResponse40050';
import { InlineResponse40051 } from '../model/inlineResponse40051';
import { InlineResponse40052 } from '../model/inlineResponse40052';
import { InlineResponse40053 } from '../model/inlineResponse40053';
import { InlineResponse40054 } from '../model/inlineResponse40054';
import { InlineResponse40055 } from '../model/inlineResponse40055';
import { InlineResponse40056 } from '../model/inlineResponse40056';
import { InlineResponse40057 } from '../model/inlineResponse40057';
import { InlineResponse40058 } from '../model/inlineResponse40058';
import { InlineResponse40059 } from '../model/inlineResponse40059';
import { InlineResponse4006 } from '../model/inlineResponse4006';
import { InlineResponse40060 } from '../model/inlineResponse40060';
import { InlineResponse40061 } from '../model/inlineResponse40061';
import { InlineResponse40062 } from '../model/inlineResponse40062';
import { InlineResponse40063 } from '../model/inlineResponse40063';
import { InlineResponse4007 } from '../model/inlineResponse4007';
import { InlineResponse4008 } from '../model/inlineResponse4008';
import { InlineResponse4009 } from '../model/inlineResponse4009';
import { InlineResponse401 } from '../model/inlineResponse401';
import { InlineResponse403 } from '../model/inlineResponse403';
import { Level } from '../model/level';
import { LevelArray } from '../model/levelArray';
import { OptionArray } from '../model/optionArray';
import { QuestionArray } from '../model/questionArray';
import { Subject } from '../model/subject';
import { SubjectArray } from '../model/subjectArray';
import { UnitArray } from '../model/unitArray';
import { User } from '../model/user';
import { UserArray } from '../model/userArray';
import { UserId } from '../model/userId';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DefaultService {

    protected basePath = '{protocol}://{environment}.example.com/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Delete an achievement.
     * Delete an achievement of a subject.
     * @param idAchievement Id of the achievement.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public achievementIdAchievementDelete(idAchievement: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20032>;
    public achievementIdAchievementDelete(idAchievement: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20032>>;
    public achievementIdAchievementDelete(idAchievement: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20032>>;
    public achievementIdAchievementDelete(idAchievement: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idAchievement === null || idAchievement === undefined) {
            throw new Error('Required parameter idAchievement was null or undefined when calling achievementIdAchievementDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20032>('delete',`${this.basePath}/achievement/${encodeURIComponent(String(idAchievement))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Check if the JWT token is valid.
     * Check if the JWT token is valid.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public authGet(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2008>;
    public authGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2008>>;
    public authGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2008>>;
    public authGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2008>('get',`${this.basePath}/auth`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a badge.
     * Delete one badge of a level by id.
     * @param idBadge Id of the badge.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public badgeIdBadgeDelete(idBadge: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20027>;
    public badgeIdBadgeDelete(idBadge: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20027>>;
    public badgeIdBadgeDelete(idBadge: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20027>>;
    public badgeIdBadgeDelete(idBadge: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idBadge === null || idBadge === undefined) {
            throw new Error('Required parameter idBadge was null or undefined when calling badgeIdBadgeDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20027>('delete',`${this.basePath}/badge/${encodeURIComponent(String(idBadge))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit the extra value of a badge.
     * Edit the extra value of a badge.
     * @param idBadge Id of the badge to be edited.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public badgeIdBadgePatch(idBadge: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20028>;
    public badgeIdBadgePatch(idBadge: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20028>>;
    public badgeIdBadgePatch(idBadge: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20028>>;
    public badgeIdBadgePatch(idBadge: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idBadge === null || idBadge === undefined) {
            throw new Error('Required parameter idBadge was null or undefined when calling badgeIdBadgePatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20028>('patch',`${this.basePath}/badge/${encodeURIComponent(String(idBadge))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the complete information of certain badge.
     * Get the complete information of certain badge by id.
     * @param badgeId Id of the badge.
     * @param badgeType Type of badge to get the right information.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public badgesBadgeIdTypeBadgeTypeGet(badgeId: number, badgeType: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public badgesBadgeIdTypeBadgeTypeGet(badgeId: number, badgeType: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public badgesBadgeIdTypeBadgeTypeGet(badgeId: number, badgeType: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public badgesBadgeIdTypeBadgeTypeGet(badgeId: number, badgeType: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (badgeId === null || badgeId === undefined) {
            throw new Error('Required parameter badgeId was null or undefined when calling badgesBadgeIdTypeBadgeTypeGet.');
        }

        if (badgeType === null || badgeType === undefined) {
            throw new Error('Required parameter badgeType was null or undefined when calling badgesBadgeIdTypeBadgeTypeGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('get',`${this.basePath}/badges/${encodeURIComponent(String(badgeId))}/type/${encodeURIComponent(String(badgeType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update the information about the earn badges during the game.
     * Update the information about the earn badges during the game. The value is a strings that will work as an array.
     * @param idLevel Id of the level played by the student
     * @param idStudent Id of the student who played.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public badgesLevelIdLevelStudentIdStudentPatch(idLevel: number, idStudent: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20029>;
    public badgesLevelIdLevelStudentIdStudentPatch(idLevel: number, idStudent: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20029>>;
    public badgesLevelIdLevelStudentIdStudentPatch(idLevel: number, idStudent: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20029>>;
    public badgesLevelIdLevelStudentIdStudentPatch(idLevel: number, idStudent: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling badgesLevelIdLevelStudentIdStudentPatch.');
        }

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling badgesLevelIdLevelStudentIdStudentPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20029>('patch',`${this.basePath}/badges/level/${encodeURIComponent(String(idLevel))}/student/${encodeURIComponent(String(idStudent))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the words for the home page blocks.
     * Get the words for the home page blocks.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public blockinformationGet(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public blockinformationGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public blockinformationGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public blockinformationGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<string>>('get',`${this.basePath}/blockinformation`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the boosterprices.
     * Get the boosterprices.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public boosterpriceGet(observe?: 'body', reportProgress?: boolean): Observable<Array<number>>;
    public boosterpriceGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<number>>>;
    public boosterpriceGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<number>>>;
    public boosterpriceGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<number>>('get',`${this.basePath}/boosterprice`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the descriptions for the homepage.
     * Get the descriptions for the homepage.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public descriptionGet(observe?: 'body', reportProgress?: boolean): Observable<Array<string>>;
    public descriptionGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<string>>>;
    public descriptionGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<string>>>;
    public descriptionGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Array<string>>('get',`${this.basePath}/description`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a set of flashcard.
     * Delete a set of flashcard by id.
     * @param idFlashcard Id of the badge.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardDelete(idFlashcard: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20034>;
    public flashcardIdFlashcardDelete(idFlashcard: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20034>>;
    public flashcardIdFlashcardDelete(idFlashcard: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20034>>;
    public flashcardIdFlashcardDelete(idFlashcard: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20034>('delete',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one set of flashcard.
     * Get one set of flashcard by id.
     * @param idFlashcard Id of the flashcard.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardGet(idFlashcard: number, observe?: 'body', reportProgress?: boolean): Observable<Flashcard>;
    public flashcardIdFlashcardGet(idFlashcard: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Flashcard>>;
    public flashcardIdFlashcardGet(idFlashcard: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Flashcard>>;
    public flashcardIdFlashcardGet(idFlashcard: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Flashcard>('get',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get flashcards items.
     * Get flashcards items by set id.
     * @param idFlashcard Id of the set of flashcards.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardItemsGet(idFlashcard: number, observe?: 'body', reportProgress?: boolean): Observable<FlashcardItemArray>;
    public flashcardIdFlashcardItemsGet(idFlashcard: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FlashcardItemArray>>;
    public flashcardIdFlashcardItemsGet(idFlashcard: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FlashcardItemArray>>;
    public flashcardIdFlashcardItemsGet(idFlashcard: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardItemsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FlashcardItemArray>('get',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}/items`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the answer to the flashcards.
     * Get all the answer to the flashcards during a period of time.
     * @param idFlashcard Id of the interested set of flashcards.
     * @param min Min months.
     * @param max Max months.
     * @param year Year use in the filter.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardMonthMinMaxYearYearGet(idFlashcard: number, min: number, max: number, year: number, observe?: 'body', reportProgress?: boolean): Observable<FlashcardResultArray>;
    public flashcardIdFlashcardMonthMinMaxYearYearGet(idFlashcard: number, min: number, max: number, year: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FlashcardResultArray>>;
    public flashcardIdFlashcardMonthMinMaxYearYearGet(idFlashcard: number, min: number, max: number, year: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FlashcardResultArray>>;
    public flashcardIdFlashcardMonthMinMaxYearYearGet(idFlashcard: number, min: number, max: number, year: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardMonthMinMaxYearYearGet.');
        }

        if (min === null || min === undefined) {
            throw new Error('Required parameter min was null or undefined when calling flashcardIdFlashcardMonthMinMaxYearYearGet.');
        }

        if (max === null || max === undefined) {
            throw new Error('Required parameter max was null or undefined when calling flashcardIdFlashcardMonthMinMaxYearYearGet.');
        }

        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling flashcardIdFlashcardMonthMinMaxYearYearGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FlashcardResultArray>('get',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}/month/${encodeURIComponent(String(min))}/${encodeURIComponent(String(max))}/year/${encodeURIComponent(String(year))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit set of flashcard title.
     * Edit set of flashcard title.
     * @param idFlashcard Id of the flashcard to be edited.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardPatch(idFlashcard: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20035>;
    public flashcardIdFlashcardPatch(idFlashcard: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20035>>;
    public flashcardIdFlashcardPatch(idFlashcard: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20035>>;
    public flashcardIdFlashcardPatch(idFlashcard: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20035>('patch',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new flashcard item.
     * Create a new flashcard item.
     * @param idFlashcard Id of the set of flashcards.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardPost(idFlashcard: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20033>;
    public flashcardIdFlashcardPost(idFlashcard: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20033>>;
    public flashcardIdFlashcardPost(idFlashcard: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20033>>;
    public flashcardIdFlashcardPost(idFlashcard: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20033>('post',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a value to know if the user can edit the flashcard.
     * Get a value to know if the user can edit the flashcard.
     * @param idFlashcard Id of the interested set of flashcards.
     * @param idUser Id of the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdFlashcardUserIdUserEditGet(idFlashcard: number, idUser: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20039>;
    public flashcardIdFlashcardUserIdUserEditGet(idFlashcard: number, idUser: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20039>>;
    public flashcardIdFlashcardUserIdUserEditGet(idFlashcard: number, idUser: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20039>>;
    public flashcardIdFlashcardUserIdUserEditGet(idFlashcard: number, idUser: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idFlashcard === null || idFlashcard === undefined) {
            throw new Error('Required parameter idFlashcard was null or undefined when calling flashcardIdFlashcardUserIdUserEditGet.');
        }

        if (idUser === null || idUser === undefined) {
            throw new Error('Required parameter idUser was null or undefined when calling flashcardIdFlashcardUserIdUserEditGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20039>('get',`${this.basePath}/flashcard/${encodeURIComponent(String(idFlashcard))}/user/${encodeURIComponent(String(idUser))}/edit`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Register the result of a flahscard item.
     * Register the result of a flahscard item when the student play.
     * @param idItem Id of the flashcard item.
     * @param idStudent Id of the student who is playing.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardIdItemStudentIdStudentPost(idItem: number, idStudent: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20038>;
    public flashcardIdItemStudentIdStudentPost(idItem: number, idStudent: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20038>>;
    public flashcardIdItemStudentIdStudentPost(idItem: number, idStudent: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20038>>;
    public flashcardIdItemStudentIdStudentPost(idItem: number, idStudent: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idItem === null || idItem === undefined) {
            throw new Error('Required parameter idItem was null or undefined when calling flashcardIdItemStudentIdStudentPost.');
        }

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling flashcardIdItemStudentIdStudentPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20038>('post',`${this.basePath}/flashcard/${encodeURIComponent(String(idItem))}/student/${encodeURIComponent(String(idStudent))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a flashcard item.
     * Delete a flashcard item by id.
     * @param idItem Id of the flashcard item.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardItemIdItemDelete(idItem: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20036>;
    public flashcardItemIdItemDelete(idItem: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20036>>;
    public flashcardItemIdItemDelete(idItem: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20036>>;
    public flashcardItemIdItemDelete(idItem: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idItem === null || idItem === undefined) {
            throw new Error('Required parameter idItem was null or undefined when calling flashcardItemIdItemDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20036>('delete',`${this.basePath}/flashcard/item/${encodeURIComponent(String(idItem))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a flashcard item content.
     * Edit a flashcard item content by id.
     * @param idItem Id of the flashcard item to be edited.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardItemIdItemPatch(idItem: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20037>;
    public flashcardItemIdItemPatch(idItem: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20037>>;
    public flashcardItemIdItemPatch(idItem: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20037>>;
    public flashcardItemIdItemPatch(idItem: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idItem === null || idItem === undefined) {
            throw new Error('Required parameter idItem was null or undefined when calling flashcardItemIdItemPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20037>('patch',`${this.basePath}/flashcard/item/${encodeURIComponent(String(idItem))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new flashcard.
     * Create a new flashcard.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardPost(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20033>;
    public flashcardPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20033>>;
    public flashcardPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20033>>;
    public flashcardPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20033>('post',`${this.basePath}/flashcard`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all available flashcards.
     * Get all available flashcards with or without filters.
     * @param idUser Id of the user who is searching.
     * @param filter Filter use to get find the desire flashcard in an easy way.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardUserIdUserFilterFilterGet(idUser: number, filter: number, observe?: 'body', reportProgress?: boolean): Observable<FlashcardArray>;
    public flashcardUserIdUserFilterFilterGet(idUser: number, filter: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FlashcardArray>>;
    public flashcardUserIdUserFilterFilterGet(idUser: number, filter: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FlashcardArray>>;
    public flashcardUserIdUserFilterFilterGet(idUser: number, filter: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUser === null || idUser === undefined) {
            throw new Error('Required parameter idUser was null or undefined when calling flashcardUserIdUserFilterFilterGet.');
        }

        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling flashcardUserIdUserFilterFilterGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FlashcardArray>('get',`${this.basePath}/flashcard/user/${encodeURIComponent(String(idUser))}/filter/${encodeURIComponent(String(filter))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one set of flashcard.
     * Get one set of flashcard by id.
     * @param idUser Id of the user who is searching.
     * @param paramSearch Desired name searched by the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public flashcardUserIdUserSearchParamSearchGet(idUser: number, paramSearch: string, observe?: 'body', reportProgress?: boolean): Observable<FlashcardArray>;
    public flashcardUserIdUserSearchParamSearchGet(idUser: number, paramSearch: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FlashcardArray>>;
    public flashcardUserIdUserSearchParamSearchGet(idUser: number, paramSearch: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FlashcardArray>>;
    public flashcardUserIdUserSearchParamSearchGet(idUser: number, paramSearch: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUser === null || idUser === undefined) {
            throw new Error('Required parameter idUser was null or undefined when calling flashcardUserIdUserSearchParamSearchGet.');
        }

        if (paramSearch === null || paramSearch === undefined) {
            throw new Error('Required parameter paramSearch was null or undefined when calling flashcardUserIdUserSearchParamSearchGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FlashcardArray>('get',`${this.basePath}/flashcard/user/${encodeURIComponent(String(idUser))}/search/${encodeURIComponent(String(paramSearch))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a level by id.
     * Delete a level by id.
     * @param id Id of the level to be deleted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdDelete(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2009>;
    public levelIdDelete(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2009>>;
    public levelIdDelete(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2009>>;
    public levelIdDelete(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling levelIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2009>('delete',`${this.basePath}/level/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the badges related to the level id.
     * Get the badges related to the level id.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdLevelBadgesGet(idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<BadgeArray>;
    public levelIdLevelBadgesGet(idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BadgeArray>>;
    public levelIdLevelBadgesGet(idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BadgeArray>>;
    public levelIdLevelBadgesGet(idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling levelIdLevelBadgesGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BadgeArray>('get',`${this.basePath}/level/${encodeURIComponent(String(idLevel))}/badges`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one or more subjects.
     * Get one or more subjects by name.
     * @param idLevel Id of the requested level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdLevelGet(idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<Level>;
    public levelIdLevelGet(idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Level>>;
    public levelIdLevelGet(idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Level>>;
    public levelIdLevelGet(idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling levelIdLevelGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Level>('get',`${this.basePath}/level/${encodeURIComponent(String(idLevel))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all the question of the level.
     * Delete all the question of the level.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdLevelQuestionDelete(idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20012>;
    public levelIdLevelQuestionDelete(idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20012>>;
    public levelIdLevelQuestionDelete(idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20012>>;
    public levelIdLevelQuestionDelete(idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling levelIdLevelQuestionDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20012>('delete',`${this.basePath}/level/${encodeURIComponent(String(idLevel))}/question`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get level questions.
     * Get the bank of level questions.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdLevelQuestionGet(idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<QuestionArray>;
    public levelIdLevelQuestionGet(idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<QuestionArray>>;
    public levelIdLevelQuestionGet(idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<QuestionArray>>;
    public levelIdLevelQuestionGet(idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling levelIdLevelQuestionGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<QuestionArray>('get',`${this.basePath}/level/${encodeURIComponent(String(idLevel))}/question`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new question.
     * Create a new question linked to a level id.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdLevelQuestionPost(idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20011>;
    public levelIdLevelQuestionPost(idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20011>>;
    public levelIdLevelQuestionPost(idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20011>>;
    public levelIdLevelQuestionPost(idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling levelIdLevelQuestionPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20011>('post',`${this.basePath}/level/${encodeURIComponent(String(idLevel))}/question`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Indicate if the student used a booster.
     * Indicate if the student used a booster while playing.
     * @param idStudent Id of the student who is playing.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdLevelStudentIdStudentUsedboosterPatch(idStudent: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20021>;
    public levelIdLevelStudentIdStudentUsedboosterPatch(idStudent: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20021>>;
    public levelIdLevelStudentIdStudentUsedboosterPatch(idStudent: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20021>>;
    public levelIdLevelStudentIdStudentUsedboosterPatch(idStudent: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling levelIdLevelStudentIdStudentUsedboosterPatch.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling levelIdLevelStudentIdStudentUsedboosterPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20021>('patch',`${this.basePath}/level/${encodeURIComponent(String(idLevel))}/student/${encodeURIComponent(String(idStudent))}/usedbooster`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit the information of a level.
     * Edit the information of a level.
     * @param id Id of the level to be edited.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdPatch(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20010>;
    public levelIdPatch(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20010>>;
    public levelIdPatch(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20010>>;
    public levelIdPatch(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling levelIdPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20010>('patch',`${this.basePath}/level/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all questions of assign to a level.
     * Get all questions of assign to a level.
     * @param id Id of the level to be played.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdQuestionsGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<QuestionArray>;
    public levelIdQuestionsGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<QuestionArray>>;
    public levelIdQuestionsGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<QuestionArray>>;
    public levelIdQuestionsGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling levelIdQuestionsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<QuestionArray>('get',`${this.basePath}/level/${encodeURIComponent(String(id))}/questions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get units of the level.
     * Get units of the level.
     * @param id Id of the level to find his units.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public levelIdUnitsGet(id: number, observe?: 'body', reportProgress?: boolean): Observable<UnitArray>;
    public levelIdUnitsGet(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UnitArray>>;
    public levelIdUnitsGet(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UnitArray>>;
    public levelIdUnitsGet(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling levelIdUnitsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UnitArray>('get',`${this.basePath}/level/${encodeURIComponent(String(id))}/units`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Login user.
     * Login user with existing account.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginPost(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public loginPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public loginPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public loginPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/login`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an specific question.
     * Delete an specific question by id.
     * @param id Id of the question.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public questionIdDelete(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20015>;
    public questionIdDelete(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20015>>;
    public questionIdDelete(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20015>>;
    public questionIdDelete(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling questionIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20015>('delete',`${this.basePath}/question/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit a question by id.
     * Edit a question by id.
     * @param id Id of the question.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public questionIdPatch(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20016>;
    public questionIdPatch(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20016>>;
    public questionIdPatch(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20016>>;
    public questionIdPatch(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling questionIdPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20016>('patch',`${this.basePath}/question/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the options assign to a question.
     * Get all the options assign to a question.
     * @param idQuestion Id of the question.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public questionIdQuestionGet(idQuestion: number, observe?: 'body', reportProgress?: boolean): Observable<OptionArray>;
    public questionIdQuestionGet(idQuestion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<OptionArray>>;
    public questionIdQuestionGet(idQuestion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<OptionArray>>;
    public questionIdQuestionGet(idQuestion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idQuestion === null || idQuestion === undefined) {
            throw new Error('Required parameter idQuestion was null or undefined when calling questionIdQuestionGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<OptionArray>('get',`${this.basePath}/question/${encodeURIComponent(String(idQuestion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit multiple options.
     * Edit multiple options of the question by his id.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public questionOptionsPatch(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20026>;
    public questionOptionsPatch(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20026>>;
    public questionOptionsPatch(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20026>>;
    public questionOptionsPatch(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20026>('patch',`${this.basePath}/question/options`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the response information after a define date.
     * Get the response information after a define date.
     * @param idStudent Id of the student who answered the questions.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param date Date value to be compared in the query.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet(idStudent: number, idSubject: number, idLevel: number, date: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20024>;
    public questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet(idStudent: number, idSubject: number, idLevel: number, date: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20024>>;
    public questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet(idStudent: number, idSubject: number, idLevel: number, date: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20024>>;
    public questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet(idStudent: number, idSubject: number, idLevel: number, date: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet.');
        }

        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling questionsStudentIdStudentSubjectIdSubjectLevelIdLevelDateGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20024>('get',`${this.basePath}/questions/student/${encodeURIComponent(String(idStudent))}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Linked a student to a subject.
     * Linked a student to a subject so he can take part in the games.
     * @param idStudent Id of student to be added to a subject.
     * @param idSubject Id of the subject where the student will be added.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentIdStudentIdSubjectPost(idStudent: number, idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2005>;
    public studentIdStudentIdSubjectPost(idStudent: number, idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2005>>;
    public studentIdStudentIdSubjectPost(idStudent: number, idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2005>>;
    public studentIdStudentIdSubjectPost(idStudent: number, idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling studentIdStudentIdSubjectPost.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling studentIdStudentIdSubjectPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2005>('post',`${this.basePath}/student/${encodeURIComponent(String(idStudent))}/${encodeURIComponent(String(idSubject))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the information about the attempts.
     * Get all the information about the attempts of an user. The information include boosters and badges.
     * @param idStudent Id of the student.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet(idStudent: number, idSubject: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<CompleteAttemptInfo>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet(idStudent: number, idSubject: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CompleteAttemptInfo>>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet(idStudent: number, idSubject: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CompleteAttemptInfo>>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet(idStudent: number, idSubject: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelAttemptGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<CompleteAttemptInfo>('get',`${this.basePath}/student/${encodeURIComponent(String(idStudent))}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/attempt`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new value or add 1 to the existed value of attempts.
     * Create a new value or add 1 to the existed value of attempts
     * @param idStudent Id of the student.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentIdStudentSubjectIdSubjectLevelIdLevelPatch(idStudent: number, idSubject: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20017>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelPatch(idStudent: number, idSubject: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20017>>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelPatch(idStudent: number, idSubject: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20017>>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelPatch(idStudent: number, idSubject: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelPatch.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelPatch.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20017>('patch',`${this.basePath}/student/${encodeURIComponent(String(idStudent))}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set the level status \&quot;finalizado\&quot; to true.
     * Set the level status \&quot;finalizado\&quot; to true.
     * @param idStudent Id of the student.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch(idStudent: number, idSubject: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20018>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch(idStudent: number, idSubject: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20018>>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch(idStudent: number, idSubject: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20018>>;
    public studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch(idStudent: number, idSubject: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling studentIdStudentSubjectIdSubjectLevelIdLevelStatusPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20018>('patch',`${this.basePath}/student/${encodeURIComponent(String(idStudent))}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the subjects of the student.
     * Get the subject of the student using his id.
     * @param userId Numeric ID of the teacher to get the subjects of the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public studentSubjectsUserIdGet(userId: number, observe?: 'body', reportProgress?: boolean): Observable<SubjectArray>;
    public studentSubjectsUserIdGet(userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubjectArray>>;
    public studentSubjectsUserIdGet(userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubjectArray>>;
    public studentSubjectsUserIdGet(userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling studentSubjectsUserIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SubjectArray>('get',`${this.basePath}/student/subjects/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new level.
     * Create a new level linked to a subject id.
     * @param id Id of the subject to linked the new level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdLevelPost(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2001>;
    public subjectIdLevelPost(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2001>>;
    public subjectIdLevelPost(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2001>>;
    public subjectIdLevelPost(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling subjectIdLevelPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2001>('post',`${this.basePath}/subject/${encodeURIComponent(String(id))}/level`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the achievement of a subject.
     * Get all the achievement of a subject that the students can earned.
     * @param idSubject Id of the subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectAchievementGet(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<AchievementArray>;
    public subjectIdSubjectAchievementGet(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AchievementArray>>;
    public subjectIdSubjectAchievementGet(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AchievementArray>>;
    public subjectIdSubjectAchievementGet(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectAchievementGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<AchievementArray>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/achievement`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new achievement.
     * Create a new achievement and assign it to a subject.
     * @param idSubject Id of the subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectAchievementPost(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20030>;
    public subjectIdSubjectAchievementPost(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20030>>;
    public subjectIdSubjectAchievementPost(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20030>>;
    public subjectIdSubjectAchievementPost(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectAchievementPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20030>('post',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/achievement`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one or more subjects.
     * Get one or more subjects by name, quarter and year.
     * @param idSubject Id of the subject that will receive the levels.
     * @param idSubjectCopy Id of the subject that will send the levels to other subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectCopyIdSubjectCopyGet(idSubject: number, idSubjectCopy: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse200>;
    public subjectIdSubjectCopyIdSubjectCopyGet(idSubject: number, idSubjectCopy: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse200>>;
    public subjectIdSubjectCopyIdSubjectCopyGet(idSubject: number, idSubjectCopy: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse200>>;
    public subjectIdSubjectCopyIdSubjectCopyGet(idSubject: number, idSubjectCopy: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectCopyIdSubjectCopyGet.');
        }

        if (idSubjectCopy === null || idSubjectCopy === undefined) {
            throw new Error('Required parameter idSubjectCopy was null or undefined when calling subjectIdSubjectCopyIdSubjectCopyGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse200>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/copy/${encodeURIComponent(String(idSubjectCopy))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the number of students that answer the questionnaire.
     * Get the number of students that answer the questionnaire.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelIdLevelAttemptsGet(idSubject: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20013>;
    public subjectIdSubjectLevelIdLevelAttemptsGet(idSubject: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20013>>;
    public subjectIdSubjectLevelIdLevelAttemptsGet(idSubject: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20013>>;
    public subjectIdSubjectLevelIdLevelAttemptsGet(idSubject: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelIdLevelAttemptsGet.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling subjectIdSubjectLevelIdLevelAttemptsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20013>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/attempts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change availability of a level.
     * Change availability of a level by level and subject id.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelIdLevelAvailabilityPatch(idSubject: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20010>;
    public subjectIdSubjectLevelIdLevelAvailabilityPatch(idSubject: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20010>>;
    public subjectIdSubjectLevelIdLevelAvailabilityPatch(idSubject: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20010>>;
    public subjectIdSubjectLevelIdLevelAvailabilityPatch(idSubject: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelIdLevelAvailabilityPatch.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling subjectIdSubjectLevelIdLevelAvailabilityPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20010>('patch',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/availability`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an answer information.
     * Delete an answer information because it wasn&#x27;t used.
     * @param idStudent Id of the student who is playing.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param idQuestion Id of the question.
     * @param date Date value to be compared in the query.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, date: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20025>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, date: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20025>>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, date: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20025>>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, date: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete.');
        }

        if (idQuestion === null || idQuestion === undefined) {
            throw new Error('Required parameter idQuestion was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete.');
        }

        if (date === null || date === undefined) {
            throw new Error('Required parameter date was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionDateDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20025>('delete',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/student/${encodeURIComponent(String(idStudent))}/question/${encodeURIComponent(String(idQuestion))}/${encodeURIComponent(String(date))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set the score won.
     * Set the score won to the score send from the front-end.
     * @param idStudent Id of the student who is playing.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param idQuestion Id of the asnwered question.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20020>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20020>>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20020>>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch.');
        }

        if (idQuestion === null || idQuestion === undefined) {
            throw new Error('Required parameter idQuestion was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20020>('patch',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/student/${encodeURIComponent(String(idStudent))}/question/${encodeURIComponent(String(idQuestion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create the new row of answered question.
     * Create the new row of answered question to be edited later.
     * @param idStudent Id of the student who is playing.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param idQuestion Id of the question to be answered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20019>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20019>>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20019>>;
    public subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost(idStudent: number, idSubject: number, idLevel: number, idQuestion: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost.');
        }

        if (idQuestion === null || idQuestion === undefined) {
            throw new Error('Required parameter idQuestion was null or undefined when calling subjectIdSubjectLevelIdLevelStudentIdStudentQuestionIdQuestionPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20019>('post',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/student/${encodeURIComponent(String(idStudent))}/question/${encodeURIComponent(String(idQuestion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the levels linked to a subject.
     * Get an array of all the levels linked to a subject.
     * @param idSubject Id of the subject to get his levels.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelsGet(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<LevelArray>;
    public subjectIdSubjectLevelsGet(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LevelArray>>;
    public subjectIdSubjectLevelsGet(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LevelArray>>;
    public subjectIdSubjectLevelsGet(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<LevelArray>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/levels`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the numbers of levels.
     * Get the numbers of levels of the subject.
     * @param idSubject Id of the subject to get the number of levels.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectLevelsamountGet(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<LevelArray>;
    public subjectIdSubjectLevelsamountGet(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LevelArray>>;
    public subjectIdSubjectLevelsamountGet(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LevelArray>>;
    public subjectIdSubjectLevelsamountGet(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectLevelsamountGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<LevelArray>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/levelsamount`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Hide a subject.
     * Hide a subject only from the students.
     * @param idSubject Id of the subject that will be hided.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectPatch(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2004>;
    public subjectIdSubjectPatch(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2004>>;
    public subjectIdSubjectPatch(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2004>>;
    public subjectIdSubjectPatch(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2004>('patch',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the achievement earned by a student in a certain subject.
     * Get all the achievement earned by a student in a certain subject.
     * @param idSubject Id of the subject.
     * @param idStudent Id of the student.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectUserIdStudentAchievementGet(idSubject: number, idStudent: number, observe?: 'body', reportProgress?: boolean): Observable<Achievement>;
    public subjectIdSubjectUserIdStudentAchievementGet(idSubject: number, idStudent: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Achievement>>;
    public subjectIdSubjectUserIdStudentAchievementGet(idSubject: number, idStudent: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Achievement>>;
    public subjectIdSubjectUserIdStudentAchievementGet(idSubject: number, idStudent: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectUserIdStudentAchievementGet.');
        }

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling subjectIdSubjectUserIdStudentAchievementGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Achievement>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/user/${encodeURIComponent(String(idStudent))}/achievement`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the user type.
     * Get the user type to allow the user to do some actions.
     * @param idSubject Id of the subject.
     * @param idUser Id of the user that takes part in the subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectUserIdUserGet(idSubject: number, idUser: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2002>;
    public subjectIdSubjectUserIdUserGet(idSubject: number, idUser: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2002>>;
    public subjectIdSubjectUserIdUserGet(idSubject: number, idUser: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2002>>;
    public subjectIdSubjectUserIdUserGet(idSubject: number, idUser: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectUserIdUserGet.');
        }

        if (idUser === null || idUser === undefined) {
            throw new Error('Required parameter idUser was null or undefined when calling subjectIdSubjectUserIdUserGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2002>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/user/${encodeURIComponent(String(idUser))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all the information about the performance of all students.
     * All the information needed to show to the teachers is \&quot;final score\&quot;, \&quot;average score\&quot; and then from each level the theacher will be able to see \&quot;attempts\&quot;, \&quot;boosters\&quot; and \&quot;badges\&quot;.
     * @param idSubject Id of the subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectUserdetailsGet(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<FinalUserInformation>;
    public subjectIdSubjectUserdetailsGet(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FinalUserInformation>>;
    public subjectIdSubjectUserdetailsGet(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FinalUserInformation>>;
    public subjectIdSubjectUserdetailsGet(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectUserdetailsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FinalUserInformation>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/userdetails`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get basic information about student performance during the games.
     * All the information needed to show to the teachers is \&quot;final score\&quot;, \&quot;average score\&quot;.
     * @param idSubject Id of the subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectUsersGet(idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<BasicUserInformationArray>;
    public subjectIdSubjectUsersGet(idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BasicUserInformationArray>>;
    public subjectIdSubjectUsersGet(idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BasicUserInformationArray>>;
    public subjectIdSubjectUsersGet(idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectUsersGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<BasicUserInformationArray>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/users`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get number of coins of the user.
     * Get number of available coins of the user in a subject.
     * @param idSubject Id of the subject.
     * @param idStudent Id of the student.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectUsersIdStudentCoinsGet(idSubject: number, idStudent: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2006>;
    public subjectIdSubjectUsersIdStudentCoinsGet(idSubject: number, idStudent: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2006>>;
    public subjectIdSubjectUsersIdStudentCoinsGet(idSubject: number, idStudent: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2006>>;
    public subjectIdSubjectUsersIdStudentCoinsGet(idSubject: number, idStudent: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectUsersIdStudentCoinsGet.');
        }

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling subjectIdSubjectUsersIdStudentCoinsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2006>('get',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/users/${encodeURIComponent(String(idStudent))}/coins`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add or subtract coins.
     * Add or subtract coins of the user.
     * @param idSubject Id of the subject.
     * @param idStudent Id of the student.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectIdSubjectUsersIdStudentCoinsPatch(idSubject: number, idStudent: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2007>;
    public subjectIdSubjectUsersIdStudentCoinsPatch(idSubject: number, idStudent: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2007>>;
    public subjectIdSubjectUsersIdStudentCoinsPatch(idSubject: number, idStudent: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2007>>;
    public subjectIdSubjectUsersIdStudentCoinsPatch(idSubject: number, idStudent: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling subjectIdSubjectUsersIdStudentCoinsPatch.');
        }

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling subjectIdSubjectUsersIdStudentCoinsPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2007>('patch',`${this.basePath}/subject/${encodeURIComponent(String(idSubject))}/users/${encodeURIComponent(String(idStudent))}/coins`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one or more subjects.
     * Get one or more subjects by name.
     * @param search Word use by the user to search for an specific or a group of subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectSearchSearchGet(search: string, observe?: 'body', reportProgress?: boolean): Observable<SubjectArray>;
    public subjectSearchSearchGet(search: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubjectArray>>;
    public subjectSearchSearchGet(search: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubjectArray>>;
    public subjectSearchSearchGet(search: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling subjectSearchSearchGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SubjectArray>('get',`${this.basePath}/subject/search/${encodeURIComponent(String(search))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get one or more subjects.
     * Get one or more subjects by name, quarter and year.
     * @param search Word use by the user to search for an specific or a group of subject.
     * @param quarter Quarter to use as a filter.
     * @param year Year to use as a filter.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectSearchSearchQuarterYearGet(search: string, quarter: number, year: number, observe?: 'body', reportProgress?: boolean): Observable<SubjectArray>;
    public subjectSearchSearchQuarterYearGet(search: string, quarter: number, year: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubjectArray>>;
    public subjectSearchSearchQuarterYearGet(search: string, quarter: number, year: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubjectArray>>;
    public subjectSearchSearchQuarterYearGet(search: string, quarter: number, year: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling subjectSearchSearchQuarterYearGet.');
        }

        if (quarter === null || quarter === undefined) {
            throw new Error('Required parameter quarter was null or undefined when calling subjectSearchSearchQuarterYearGet.');
        }

        if (year === null || year === undefined) {
            throw new Error('Required parameter year was null or undefined when calling subjectSearchSearchQuarterYearGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SubjectArray>('get',`${this.basePath}/subject/search/${encodeURIComponent(String(search))}/${encodeURIComponent(String(quarter))}/${encodeURIComponent(String(year))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all the subjects.
     * Delect all the subjects that are registered.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsDelete(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public subjectsDelete(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public subjectsDelete(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public subjectsDelete(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/subjects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return all subjects.
     * Return all the subjects available without distinguishing the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsGet(observe?: 'body', reportProgress?: boolean): Observable<SubjectArray>;
    public subjectsGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubjectArray>>;
    public subjectsGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubjectArray>>;
    public subjectsGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SubjectArray>('get',`${this.basePath}/subjects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This operation is not avilable.
     * This operation is not avilable.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsPost(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public subjectsPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public subjectsPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public subjectsPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/subjects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This operation is not avilable.
     * This operation is not avilable to edit all subjects
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsPut(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public subjectsPut(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public subjectsPut(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public subjectsPut(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('put',`${this.basePath}/subjects`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a subject.
     * Delete a subject with some ID.
     * @param subjectId Numeric ID of the subject to delete.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsSubjectIdDelete(subjectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public subjectsSubjectIdDelete(subjectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public subjectsSubjectIdDelete(subjectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public subjectsSubjectIdDelete(subjectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (subjectId === null || subjectId === undefined) {
            throw new Error('Required parameter subjectId was null or undefined when calling subjectsSubjectIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/subjects/${encodeURIComponent(String(subjectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return one subject.
     * Return one subject by id.
     * @param subjectId Numeric ID of the subject to get.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsSubjectIdGet(subjectId: number, observe?: 'body', reportProgress?: boolean): Observable<Subject>;
    public subjectsSubjectIdGet(subjectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Subject>>;
    public subjectsSubjectIdGet(subjectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Subject>>;
    public subjectsSubjectIdGet(subjectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (subjectId === null || subjectId === undefined) {
            throw new Error('Required parameter subjectId was null or undefined when calling subjectsSubjectIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'aplication/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<Subject>('get',`${this.basePath}/subjects/${encodeURIComponent(String(subjectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit some fields.
     * Edit some fields of the subject that are selected in the front-end.
     * @param subjectId Numeric ID of the subject to patch.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsSubjectIdPatch(subjectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public subjectsSubjectIdPatch(subjectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public subjectsSubjectIdPatch(subjectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public subjectsSubjectIdPatch(subjectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (subjectId === null || subjectId === undefined) {
            throw new Error('Required parameter subjectId was null or undefined when calling subjectsSubjectIdPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/subjects/${encodeURIComponent(String(subjectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a new subject.
     * Add a new subject using the teacher Id on parameters.
     * @param teacherId Numeric ID of the teacher to add a new subject.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subjectsTeacherIdPost(teacherId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public subjectsTeacherIdPost(teacherId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public subjectsTeacherIdPost(teacherId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public subjectsTeacherIdPost(teacherId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (teacherId === null || teacherId === undefined) {
            throw new Error('Required parameter teacherId was null or undefined when calling subjectsTeacherIdPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('post',`${this.basePath}/subjects/${encodeURIComponent(String(teacherId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Linked a student to a subject.
     * Linked a student to a subject so he can edit every aspect of the subject.
     * @param idTeacher Id of teacher to be added to a subject.
     * @param idSubject Id of the subject where the teacher will be added.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public teacherIdTeacherIdSubjectPost(idTeacher: number, idSubject: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2005>;
    public teacherIdTeacherIdSubjectPost(idTeacher: number, idSubject: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2005>>;
    public teacherIdTeacherIdSubjectPost(idTeacher: number, idSubject: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2005>>;
    public teacherIdTeacherIdSubjectPost(idTeacher: number, idSubject: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idTeacher === null || idTeacher === undefined) {
            throw new Error('Required parameter idTeacher was null or undefined when calling teacherIdTeacherIdSubjectPost.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling teacherIdTeacherIdSubjectPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2005>('post',`${this.basePath}/teacher/${encodeURIComponent(String(idTeacher))}/${encodeURIComponent(String(idSubject))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the subjects of the teacher.
     * Get the subject of the teacher using his id.
     * @param userId Numeric ID of the teacher to get the subjects of the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public teacherSubjectsUserIdGet(userId: number, observe?: 'body', reportProgress?: boolean): Observable<SubjectArray>;
    public teacherSubjectsUserIdGet(userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubjectArray>>;
    public teacherSubjectsUserIdGet(userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubjectArray>>;
    public teacherSubjectsUserIdGet(userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling teacherSubjectsUserIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SubjectArray>('get',`${this.basePath}/teacher/subjects/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an specific unit.
     * Delete an specific unit by id.
     * @param id Id of the unit.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unitIdDelete(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20022>;
    public unitIdDelete(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20022>>;
    public unitIdDelete(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20022>>;
    public unitIdDelete(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling unitIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20022>('delete',`${this.basePath}/unit/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit the unit title.
     * Edit the unit title.
     * @param id Id of the unit.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unitIdPatch(id: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20023>;
    public unitIdPatch(id: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20023>>;
    public unitIdPatch(id: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20023>>;
    public unitIdPatch(id: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling unitIdPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20023>('patch',`${this.basePath}/unit/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a badge.
     * Delete one badge of a level by id.
     * @param idStudent Id of the student who earned the achievement.
     * @param idAchievement Id of the achievement.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userIdStudentAchievementIdAchievementDelete(idStudent: number, idAchievement: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20031>;
    public userIdStudentAchievementIdAchievementDelete(idStudent: number, idAchievement: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20031>>;
    public userIdStudentAchievementIdAchievementDelete(idStudent: number, idAchievement: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20031>>;
    public userIdStudentAchievementIdAchievementDelete(idStudent: number, idAchievement: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling userIdStudentAchievementIdAchievementDelete.');
        }

        if (idAchievement === null || idAchievement === undefined) {
            throw new Error('Required parameter idAchievement was null or undefined when calling userIdStudentAchievementIdAchievementDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20031>('delete',`${this.basePath}/user/${encodeURIComponent(String(idStudent))}/achievement/${encodeURIComponent(String(idAchievement))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assign an anchievement.
     * Assign an anchievement to a student when the teacher decide.
     * @param idStudent Id of the student who won the achievement.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userIdStudentAchievementPost(idStudent: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20030>;
    public userIdStudentAchievementPost(idStudent: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20030>>;
    public userIdStudentAchievementPost(idStudent: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20030>>;
    public userIdStudentAchievementPost(idStudent: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idStudent === null || idStudent === undefined) {
            throw new Error('Required parameter idStudent was null or undefined when calling userIdStudentAchievementPost.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20030>('post',`${this.basePath}/user/${encodeURIComponent(String(idStudent))}/achievement`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the number of attempts made by an individual user.
     * Get the number of attempts made by an individual user to know if he can play again or to compare the value to subtract the final score.
     * @param idUser Id of the user.
     * @param idSubject Id of the subject.
     * @param idLevel Id of the level.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet(idUser: number, idSubject: number, idLevel: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20014>;
    public userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet(idUser: number, idSubject: number, idLevel: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20014>>;
    public userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet(idUser: number, idSubject: number, idLevel: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20014>>;
    public userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet(idUser: number, idSubject: number, idLevel: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUser === null || idUser === undefined) {
            throw new Error('Required parameter idUser was null or undefined when calling userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet.');
        }

        if (idSubject === null || idSubject === undefined) {
            throw new Error('Required parameter idSubject was null or undefined when calling userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet.');
        }

        if (idLevel === null || idLevel === undefined) {
            throw new Error('Required parameter idLevel was null or undefined when calling userIdUserSubjectIdSubjectLevelIdLevelAllowattemptsGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse20014>('get',`${this.basePath}/user/${encodeURIComponent(String(idUser))}/subject/${encodeURIComponent(String(idSubject))}/level/${encodeURIComponent(String(idLevel))}/allowattempts`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get if the user is a teacher.
     * Get if the user is a teacher to allow him to access a page.
     * @param idUser Id of the user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public userIdUserTaskGet(idUser: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2003>;
    public userIdUserTaskGet(idUser: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2003>>;
    public userIdUserTaskGet(idUser: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2003>>;
    public userIdUserTaskGet(idUser: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUser === null || idUser === undefined) {
            throw new Error('Required parameter idUser was null or undefined when calling userIdUserTaskGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2003>('get',`${this.basePath}/user/${encodeURIComponent(String(idUser))}/task`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete all users.
     * Delete all users that exists without any distinguishing.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersDelete(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersDelete(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersDelete(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersDelete(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/users`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add new external user.
     * Add new user from Google or Facebook.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersExternalPost(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2005>;
    public usersExternalPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2005>>;
    public usersExternalPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2005>>;
    public usersExternalPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2005>('post',`${this.basePath}/users/external`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return all users.
     * Return all users that exists without any distinguishing.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersGet(observe?: 'body', reportProgress?: boolean): Observable<UserArray>;
    public usersGet(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UserArray>>;
    public usersGet(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UserArray>>;
    public usersGet(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<UserArray>('get',`${this.basePath}/users`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit user password.
     * Edit user password by id.
     * @param userId Numeric ID of the user to edit his password.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersPasswordUserIdPatch(userId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersPasswordUserIdPatch(userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersPasswordUserIdPatch(userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersPasswordUserIdPatch(userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersPasswordUserIdPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/users/password/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * This request is not available.
     * This request is not available.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersPatch(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersPatch(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersPatch(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersPatch(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/users`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add new user.
     * Add new inactive user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersPost(observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2005>;
    public usersPost(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2005>>;
    public usersPost(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2005>>;
    public usersPost(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<InlineResponse2005>('post',`${this.basePath}/users`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete one user.
     * Delete one user by id.
     * @param userId Numeric ID of the user to edit an exact user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersUserIdDelete(userId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersUserIdDelete(userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersUserIdDelete(userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersUserIdDelete(userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersUserIdDelete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('delete',`${this.basePath}/users/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return one user.
     * Return one user by a param can be an email or a number.
     * @param userId Numeric ID of the user to get an exact user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersUserIdGet(userId: UserId, observe?: 'body', reportProgress?: boolean): Observable<User>;
    public usersUserIdGet(userId: UserId, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;
    public usersUserIdGet(userId: UserId, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;
    public usersUserIdGet(userId: UserId, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersUserIdGet.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<User>('get',`${this.basePath}/users/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit some fields.
     * Edit some fields of the user information, you can&#x27;t edit the password with this request.
     * @param userId Numeric ID of the user to edit an exact user.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public usersUserIdPatch(userId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public usersUserIdPatch(userId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public usersUserIdPatch(userId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public usersUserIdPatch(userId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling usersUserIdPatch.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<any>('patch',`${this.basePath}/users/${encodeURIComponent(String(userId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
